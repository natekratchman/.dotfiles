# File Structure and Organization

Guidelines for organizing Ruby-based Skills with proper file references.

## Directory Structure Patterns

### Minimal Skill

```
skill-name/
├── SKILL.md          # Entry point
└── skill.rb          # All logic in one file
```

Best for: Simple skills with straightforward logic, few branches.

### Standard Skill

```
skill-name/
├── SKILL.md          # Entry point
├── skill.rb          # Core logic and routing
├── cookbook/         # Instruction variants
│   ├── default.md
│   └── advanced.md
└── prompts/          # Output templates
    └── output.md
```

Best for: Skills with 2-4 workflow variants, consistent output format.

### Complex Skill

```
skill-name/
├── SKILL.md          # Entry point
├── skill.rb          # Orchestration logic
├── cookbook/         # Instruction modules
│   ├── workflows/
│   │   ├── creation.md
│   │   ├── editing.md
│   │   └── analysis.md
│   └── handlers/
│       ├── pdf.md
│       ├── docx.md
│       └── data.md
├── prompts/          # Templates by type
│   ├── reports/
│   │   ├── summary.md
│   │   └── detailed.md
│   └── errors/
│       └── validation.md
├── tools/            # Executable helpers
│   ├── validators/
│   │   └── schema.rb
│   └── processors/
│       └── transform.rb
└── references/       # Domain knowledge
    ├── api_docs.md
    └── schemas.md
```

Best for: Multi-domain skills, extensive file type support, complex routing.

## File Reference Patterns

### From skill.rb to Cookbooks

```ruby
# Direct reference
load_cookbook("creation")
# Loads: cookbook/creation.md

# Nested reference
load_cookbook("workflows/creation")
# Loads: cookbook/workflows/creation.md

# Dynamic reference
workflow = detect_workflow(context)
load_cookbook("workflows/#{workflow}")
# Loads: cookbook/workflows/<detected>.md
```

### From skill.rb to Prompts

```ruby
# Direct reference
load_prompt("output")
# Loads: prompts/output.md

# Nested reference
load_prompt("reports/summary")
# Loads: prompts/reports/summary.md

# Conditional selection
template = context.user_input.match?(/brief/) ? "summary" : "detailed"
load_prompt("reports/#{template}")
```

### From skill.rb to Tools

```ruby
# Direct reference
load_tool("tools/validator.rb")

# Nested reference  
load_tool("tools/validators/schema.rb")

# Conditional loading
if context.files.any? { |f| f.extension == ".pdf" }
  load_tool("tools/processors/pdf.rb")
end
```

### From skill.rb to References

```ruby
# Load when specific knowledge needed
load_reference("api_docs")
# Loads: references/api_docs.md

# Conditional loading
if needs_schema_reference?(context)
  load_reference("schemas")
end
```

## Cross-File Communication

### Cookbooks Referencing Other Files

Cookbooks (markdown) can instruct Claude to load additional files:

```markdown
<!-- cookbook/creation.md -->
# Creation Workflow

## Setup
Before proceeding, ensure the appropriate tool is loaded:
- For PDF output: Load `tools/pdf_generator.rb`
- For DOCX output: Load `tools/docx_generator.rb`

## Process
1. Gather requirements
2. Generate content
3. Apply formatting from `prompts/formatting_rules.md`
4. Validate output
```

### Prompts Referencing Variables

Prompts use `{{variable}}` syntax for dynamic content:

```markdown
<!-- prompts/output.md -->
# {{title}}

## Summary
{{summary_content}}

## Details
Generated by: {{workflow_name}}
Files processed: {{file_count}}

{{#if has_warnings}}
## Warnings
{{warnings}}
{{/if}}
```

### Tools Returning to Workflow

Tools can emit instructions that influence workflow:

```ruby
# tools/validator.rb
def validate(content)
  if content.length < MIN_LENGTH
    emit "VALIDATION: Content too short, load cookbook/expansion_tips.md"
    return { valid: false, action: :expand }
  end
  
  { valid: true }
end
```

## Naming Conventions

### Files

| Type | Convention | Examples |
|------|------------|----------|
| Cookbooks | `snake_case.md` | `data_processing.md`, `quick_start.md` |
| Prompts | `snake_case.md` | `error_message.md`, `output_report.md` |
| Tools | `snake_case.rb` | `pdf_handler.rb`, `validator.rb` |
| References | `snake_case.md` | `api_docs.md`, `style_guide.md` |

### Directories

| Type | Convention | Examples |
|------|------------|----------|
| Category dirs | `snake_case/` | `workflows/`, `file_handlers/` |
| Feature dirs | `snake_case/` | `validation/`, `output_formats/` |

### Constants

```ruby
# Use SCREAMING_SNAKE_CASE for skill configuration
CONSTANTS = {
  MAX_FILE_SIZE: 10_000_000,
  DEFAULT_FORMAT: "markdown",
  SUPPORTED_TYPES: %w[pdf docx txt]
}

# Use symbols for internal routing
ROUTES = {
  create: "cookbook/creation.md",
  edit: "cookbook/editing.md"
}
```

## File Loading Strategy

### Eager Loading

Load files at skill initialization:

```ruby
# skill.rb
def initialize
  @base_cookbook = read_file("cookbook/base.md")
  @common_prompt = read_file("prompts/common.md")
end

def execute(context)
  # @base_cookbook and @common_prompt already loaded
  emit @base_cookbook
  # ...
end
```

Best for: Files used in every execution path.

### Lazy Loading

Load files only when needed:

```ruby
def execute(context)
  if needs_advanced_processing?(context)
    load_cookbook("advanced_processing")
    load_tool("tools/advanced_processor.rb")
  end
end
```

Best for: Files used in specific branches, large files.

### Progressive Loading

Load files in stages as workflow progresses:

```ruby
def execute(context)
  # Stage 1: Always load
  load_cookbook("initialization")
  
  # Stage 2: After classification
  category = classify_request(context)
  load_cookbook("categories/#{category}")
  
  # Stage 3: If complex processing needed
  if context.files.count > 5
    load_cookbook("batch_processing")
    load_reference("performance_tips")
  end
  
  # Stage 4: Output phase
  load_prompt(select_output_template(context))
end
```

Best for: Multi-stage workflows, performance optimization.

## Error Handling for File References

```ruby
def safe_load_cookbook(name)
  path = "cookbook/#{name}.md"
  
  if file_exists?(path)
    load_cookbook(name)
  else
    emit "Warning: Cookbook '#{name}' not found, using fallback"
    load_cookbook("fallback")
  end
end

def load_with_fallback(primary, fallback)
  if file_exists?(primary)
    read_file(primary)
  else
    read_file(fallback)
  end
end
```
